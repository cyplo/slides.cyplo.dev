export { condensed as theme } from '@mdx-deck/themes'
import { Notes } from 'mdx-deck'


# Rust in 2019

---

# Rust is the most loved language in the Stack Overflow survey.
> 4th year in the row

<Notes>
Think of a Language that would make you feel that.
Okay to interrupt
What do you look for when choosing a programming tool ?
What makes you "like" a programming language ?
Think of tools, ecosystem, community.
</Notes>

---

# Rust has been built community-first
```
"I only work with languages starting with Ru- now" - Steve Klabnik
"He isn't really your uncle" - Bodil Stokke
```
* people really eager to help
* lotta crates
* rusty puns
* documentation is excellent
* new compiler version every 6 weeks, always backwards compatible

<Notes>
Rust founders were acutely aware of this, and added community tools early
* github - development in the open, listening to feedback
* rfc process, on github as well
* forums, irc
* podcasts
* Rust thanks

It is very often. It is very stable as well.
crater, big query

"
We will use a variation of the train model, first introduced in web browsers and now widely used to provide stability without stagnation:
New work lands directly in the master branch.
Each day, the last successful build from master becomes the new nightly release.
Every six weeks, a beta branch is created from the current state of master, and the previous beta is promoted to be the new stable release.
In short, there are three release channels – nightly, beta, and stable – with regular, frequent promotions from one channel to the next.
"
</Notes>

---

# Usage in the wild

* CDNs - Fastly, Cloudflare, AWS through WASM
* Critical paths in large codebases - VLC, Firefox, Dropbox
* Your favourite CLI tools - ripgrep, fd, lsd, bat, etc
* Embedded devices

<Notes>
"For a long while now I’ve been worried that the GNOME project would struggle to grow its contribution and stay attractive if it stuck to C in the long run (i.e. next 10-20 years)." - Alberto Ruiz
</Notes>

---

## ~~Package~~  ~~Build~~ World manager

```
$ cargo new hello
   Created binary (application) `hello` package
$ cd hello/
$ cargo run
   Compiling hello v0.1.0 (/home/cyryl/temp/hello)
   Finished dev [unoptimized + debuginfo] target(s) in 0.23s
   Running `target/debug/hello`

Hello, world!

$ git status
   On branch master
```

<Notes>
A small but important step towards sanity
Made by experience package manager makers
</Notes>

---


# The usual stuff, yet quite nice

```rust
println!("{} days", 31);
println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob");
println!("{subject} {verb} {object}",
            object="the lazy dog",
            subject="the quick brown fox",
            verb="jumps over");
```

---

```rust
println!("My name is {0}, {1} {0}", "Bond");
```
= >
```
error: invalid reference to positional argument 1 (there is 1 argument)
  --> src/main.rs:31:31
   |
31 |     println!("My name is {0}, {1} {0}", "Bond");
   |                               ^^^
   |
   = note: positional arguments are zero-based
```

---

```rust
enum WebEvent {
    PageLoad,
    PageUnload,
    KeyPress(char),
    Paste(String),
    Click { x: i64, y: i64 },
    OneMore
}

fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad => println!("page loaded"),
        WebEvent::PageUnload => println!("page unloaded"),
        WebEvent::KeyPress(c) => println!("pressed '{}'.", c),
        WebEvent::Paste(s) => println!("pasted \"{}\".", s),
        WebEvent::Click { x, y } => {
            println!("clicked at x={}, y={}.", x, y);
        },
    }
}
```

---

```
error[E0004]: non-exhaustive patterns: `OneMore` not covered
  --> src/main.rs:17:11
   |
4  | / enum Message {
5  | |     Quit,
6  | |     ChangeColor(i32, i32, i32),
7  | |     Move { x: i32, y: i32 },
8  | |     Write(String),
9  | |     OneMore
   | |     ------- not covered
10 | | }
   | |_- `main::Message` defined here
...
17 |       match msg {
   |             ^^^ pattern `OneMore` not covered
   |
   = help: ensure that all possible cases are being handled,
     possibly by adding wildcards or more match arms
```

---

## Everything is almost
## exactly the same

```rust
fn take(v: Vec<i32>) {
    // what happens here isn’t important.
}

fn main() {
    let v = vec![1, 2, 3];
    take(v);
    println!("v[0] is: {}", v[0]);
}
```

---

# Then suddenly
```
error[E0382]: use of moved value: `v`
  --> src/main.rs:10:29
   |
8  |     take(v);
   |          - value moved here
9  |
10 |     println!("v[0] is: {}", v[0]);
   |                             ^ value used here after move
```

<Notes>
Note:
This is different !
https://play.rust-lang.org/?gist=ef8d8f5bac2383e5e3bd0aaa4c593650&version=stable&backtrace=0

Vec has a 'pointer' on the stack to stuff on the heap
Rust disallows having two pointers to the same stuff at the same time

https://doc.rust-lang.org/stable/book/ownership.html
</Notes>

---

# Rust - the language

```
Fast, safe, concurrent.
Pick three.
```

* no gc
* no inheritance
* no segfaults
* no data races - sharing variables between threads is safe !
* no null
* no exceptions
* predictable latency
* predictable memory usage

<Notes>
we haven't touched the language itself yet
I think this is a modern language.
Multiparadigm, functional, procedural
</Notes>

---

# But there are `Copy` types

Note:
https://play.rust-lang.org/?gist=f717140e7c1ff276161588dc07ff4a4b&version=stable&backtrace=0

---

# Which in reality, are `Traits`

Note:
http://rustbyexample.com/trait.html
https://doc.rust-lang.org/stable/book/traits.html

---

# And Borrowing

Note:

https://doc.rust-lang.org/stable/book/references-and-borrowing.html
http://rustbyexample.com/scope/borrow.html
https://play.rust-lang.org/?gist=9051cca0030b2ad3f4e89d5e92e7961f&version=stable&backtrace=0

---

# Summary

* unique memory model
* steep initial learning curve - pair program !
* powerful ecosystem
* code ages well
* cool and weird and useful
* you should try it

```